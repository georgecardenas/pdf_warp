\chapter{Descripción informática}
En este capítulo se realiza un análisis del proceso de desarrollo del proyecto, explicando la aplicación de la metodología, los hitos cumplidos en el desarrollo del proyecto e incluyendo toda la información relevante sobre el funcionamiento de la aplicación.
\section{Aplicación de la metodología Scrum}
\label{sec:metscrum}
En este proyecto se aplica la metodología Scrum adaptada a \ac{TFM} como hemos explicado en la Sección \ref{sec:scrumtfm}. El tutor del proyecto toma el rol de propietario del producto y el alumno de desarrollador. El rol de \textit{Scrum Master} se divide entre tutor y alumno.

\subsection{Primera reunión 04/05/2017}
En la primera reunión se trata todo lo referente al inicio del proyecto. El propietario del producto explica al desarrollador cual es el objetivo final del \ac{TFM}: desarrollar un módulo para Drupal para la generación de PDF a partir de catálogos y productos de Ubercart. Se dan también los primeros detalles que debería contener la herramienta.
Debido a que el desarrollador desconoce Drupal, se crea la primera tarea técnica de instalación, gestión y estudio de este \textit{framework}. A partir de el \textit{product backlog} del cuál se puede observar su estado tras la primera reunión en la Tabla \ref{tab:pb01}, se establece el primer \textit{sprint} (Tabla \ref{tab:sb01}) y se da un plazo de 2 a 3 semanas para terminarlo.

\begin{table}
	\centering
	\begin{tabular}{ | c | p{3cm} | p{8cm} | c |}
		\hline
		ID & Alias & Enunciado & \textit{Sprint}\\ \hline
		HT01 & Instalación de Entorno & Yo como desarrollador\newline necesito montar un entorno de Drupal 7\newline para poder desarrollar la aplicación & \#1\\ \hline
	\end{tabular}
	\caption{\textit{Product Backlog} 04/05/2017}\label{tab:pb01}
\end{table}

\begin{table}
	\centering
	\begin{tabular}{ | c | c | p{7cm} | c |}
		\hline
		ID & ID Tarea & Descripción & Esfuerzo\\ \hline
		HT01 & TT01.1 & Instalar Drupal 7 & 8\\ \hline
		HT01 & TT01.2 & Instalar base de datos & 8\\ \hline
		HT01 & TT01.3 & Instalar módulo & 5\\ \hline
		HT01 & TT01.4 & Instalar tema & 5\\ \hline
		HT01 & TT01.5 & Crear contenido & 3\\ \hline
		HT01 & TT01.6 & Crear tipos de contenido & 3\\ \hline
		HT01 & TT01.7 & Crear bloques & 2\\ \hline
		HT01 & TT01.8 & Crear vistas & 2\\ \hline
	\end{tabular}
	\caption{\textit{Sprint} \#1}\label{tab:sb01}
\end{table}

\subsection{Segunda reunión 25/05/2017}
En la segunda reunión se muestra al propietario del producto las tareas realizadas con resultado satisfactorio. Al haber completado con éxito el primer \textit{sprint} y haber demostrado el desarrollador soltura a la hora de utilizar el \textit{framework} de Drupal, se comienza a hablar de la funcionalidad que debe cumplir el \ac{TFM}. Se establecen nuevas historias de usuario para el \textit{product backlog} estableciendo como prioritarias aquellas relacionadas con la generación de documentos PDF. Se actualiza el \textit{product backlog} como se puede observar en la Tabla \ref{tab:pb02} y se establece el nuevo \textit{sprint} (Tabla \ref{tab:sb02}) con una duración de una semana.

\begin{table}[h]
	\centering
	\scriptsize{
	\begin{tabular}{ | c | p{2.5cm} | p{10cm} | c |}
		\hline
		ID & Alias & Enunciado & \textit{Sprint}\\ \hline
		HT01 & Instalación de Entorno & Yo como desarrollador\newline necesito montar un entorno de Drupal 7\newline para poder desarrollar la aplicación & \#1\\ \hline
		H01 & Botón de generación de PDF de producto & Yo como usuario\newline necesito ver un botón de generación de PDF para Productos\newline para poder generar un documento PDF & \#2\\ \hline
		H02 & Generación de PDF de producto & Yo como usuario\newline debo ser capaz de generar PDF a partir de Productos\newline para su posterior consulta offline & \#2\\ \hline
		HT02 & Creación de vistas programáticamente & Yo como desarrollador\newline debo crear las vistas JSON del módulo programáticamente\newline para que el usuario no tenga que realizar trabajo extra en la fase de instalación & \#2\\ \hline
	\end{tabular}}
	\caption{\textit{Product Backlog} 25/05/2017}\label{tab:pb02}
\end{table}

\begin{table}
	\centering
	\begin{tabular}{ | c | c | p{7cm} | c |}
		\hline
		ID & ID Tarea & Descripción & Esfuerzo\\ \hline
		H01 & T01.1 & Crear Hooks & 2\\ \hline
		H02 & T02.1 & Integrar librería pdf & 5\\ \hline
		H02 & T02.2 & Programar funciones de conversión a PDF según la librería & 8\\ \hline
		H02 & T02.3 & Añadir funcionalidad a botón H02 & 2\\ \hline
		HT02 & TT02.1 & Añadir vistas por código en el fichero de instalación & 5\\ \hline
	\end{tabular}
	\caption{\textit{Sprint} \#2}\label{tab:sb02}
\end{table}

\subsection{Tercera reunión 01/06/2017}
Tras la implementación del segundo \textit{sprint} se lleva a cabo la revisión de las tareas realizadas. En este momento el propietario del producto informa que hay nuevas historias de usuario que implican cambios en la idea inicial del procedimiento. Además de la generación PDF, debe ser posible que un usuario administrador cree y gestione nuevas plantillas que serán aplicadas en el momento de la generación. Se pide también que además de la generación de PDF de productos independientes se implemente la generación de PDF de catálogos de productos. Al haber demasiadas historias de usuario en el \textit{product backlog} como se puede ver en la Tabla \ref{tab:pb03} se decide dividir las tareas en dos \textit{sprints} que serán ejecutados en sucesión. La definición del tercer \textit{sprint} se puede ver en la Tabla \ref{tab:sb03} la duración del mismo será de 2 semanas.

\begin{table}
	\centering
	\scriptsize{
	\begin{tabular}{ | c | p{2.5cm} | p{10cm} | c |}
		\hline
		ID & Alias & Enunciado & \textit{Sprint}\\ \hline
		HT01 & Instalación de Entorno & Yo como desarrollador\newline necesito montar un entorno de Drupal 7\newline para poder desarrollar la aplicación & \#1\\ \hline
		H01 & Botón de generación de PDF de producto & Yo como usuario\newline necesito ver un botón de generación de PDF para Productos\newline para poder generar un documento PDF & \#2\\ \hline
		H02 & Generación de PDF de producto & Yo como usuario\newline debo ser capaz de generar PDF a partir de Productos\newline para su posterior consulta offline & \#2\\ \hline
		HT02 & Creación de vistas programáticamente & Yo como desarrollador\newline debo crear las vistas JSON del módulo programáticamente\newline para que el usuario no tenga que realizar trabajo extra en la fase de instalación & \#2\\ \hline
		H03 & Creación de plantillas de producto & Yo como administrador\newline debo ser capaz de crear plantillas para la generación de PDFs de Productos\newline para que el usuario genere un PDF atractivo & \#3\\ \hline
		H04 & Asignación de plantillas de producto & Yo como administrador\newline necesito poder asignar una plantilla de PDF a Productos\newline para que se genere un PDF con los elementos posicionados de acorde a la plantilla & \#3\\ \hline
		H05 & Mover elementos en plantillas de producto & Yo como administrador\newline necesito poder mover elementos en una plantilla pdf de producto\newline para posicionarlos donde crea conveniente & \#3\\ \hline
		H06 & Borrado de plantillas de producto & Yo como administrador\newline debo ser capaz de borrar plantillas PDF de producto\newline para que no se acumulen plantillas sin uso & \#3\\ \hline
		H07 & Acceso a sección de gestión de plantillas & Yo como administrador\newline necesito un botón en la sección de admnistración\newline para poder acceder a la sección de gestión de plantillas & \#3\\ \hline
		H08 & Botón de generación de PDF de catálogo & Yo como usuario\newline necesito ver un botón de generación de PDF para catálogos\newline para poder generar un documento PDF & \#4\\ \hline
		H09 & Generación de PDF de catálogo & Yo como usuario\newline debo ser capaz de generar PDFs a partir de catálogos\newline para su posterior consulta offline & \#4\\ \hline
		H10 & Creación de plantillas de catálogo & Yo como administrador\newline debo ser capaz de crear plantillas para la generación de PDFs de catálogos\newline para que el usuario genere un PDF atractivo & \#4\\ \hline
		H11 & Asignación de plantillas de catálogo & Yo como administrador\newline necesito poder asignar una plantilla de PDF a catálogos\newline para que se genere un PDF con los elementos posicionados de acorde a la plantilla & \#4\\ \hline
		H12 & Mover elementos en plantillas de catálogo & Yo como administrador\newline necesito poder mover elementos en una plantilla pdf de catálogo\newline para posicionarlos donde crea conveniente & \#4\\ \hline
		H13 & Borrado de plantillas de catálogo & Yo como administrador\newline debo ser capaz de borrar plantillas PDF de catálogo\newline para que no se acumulen plantillas sin uso & \#4\\ \hline
	\end{tabular}}
	\caption{\textit{Product Backlog} 01/06/2017}\label{tab:pb03}
\end{table}

\begin{table}
	\centering
	\begin{tabular}{ | c | c | p{7cm} | c |}
		\hline
		ID & ID Tarea & Descripción & Esfuerzo\\ \hline		
		H03 & T03.1 & Crear tablas de base de datos & 8\\ \hline
		H03 & T03.2 & Crear vistas de administración & 8\\ \hline
		H03 & T03.3 & Crear funciones en \textit{back-end} de creación de plantillas & 5\\ \hline
		H04 & T04.1 & Crear funciones \textit{back-end} para la asignación de plantillas & 5\\ \hline
		H04 & T04.2 & Crear vista para la asignación de plantillas & 5\\ \hline
		H05 & T05.1 & Integración de librerías \textit{front-end} & 8\\ \hline
		H05 & T05.2 & Creación de vistas & 3\\ \hline
		H05 & T05.3 & Funciones de edición & 8\\ \hline
		H05 & T05.4 & Funciones de actualización de base de datos & 5\\ \hline
		H06 & T06.1 & Vistas para borrado & 3\\ \hline
		H06 & T06.2 & Funciones de borrado de base de datos & 3\\ \hline
		H07 & T07.1 & Creación de botón en \textit{back-end} & 5\\ \hline
	\end{tabular}
	\caption{\textit{Sprint} \#3}\label{tab:sb03}
\end{table}

\subsection{Cuarta reunión 16/06/2017}
Se lleva a cabo la cuarta reunión revisando las tareas realizadas en el tercer \textit{sprint}. El resultado es satisfactorio y se planifica el siguiente conjunto de tareas a realizar a partir de las historias de usuario restantes en el \textit{product backlog}. El estado del product backlog se mantiene de acuerdo a lo definido en la Tabla \ref{tab:pb03}. Se define el \textit{sprint} de la Tabla \ref{tab:sb04}. La menor complejidad de estas tareas, ya que están muy relacionadas con las tareas del tercer \textit{sprint} y la experiencia previa, permite que el tiempo asignado para estas tareas sea de una semana.

\begin{table}
	\centering
	\begin{tabular}{ | c | c | p{7cm} | c |}
		\hline
		ID & ID Tarea & Descripción & Esfuerzo\\ \hline
		H08 & T08.1 & Crear Hooks & 2\\ \hline
		H09 & T09.1 & Programar funciones de conversión a PDF según la librería & 5\\ \hline
		H09 & T09.2 & Añadir funcionalidad a botón H02 & 2\\ \hline
		H10 & T10.1 & Crear vistas de administración & 5\\ \hline
		H10 & T10.2 & Crear funciones en back-end de creación de plantillas & 5\\ \hline
		H11 & T11.1 & Crear funciones back-end para la asignación de plantillas & 5\\ \hline
		H11 & T11.2 & Crear vista para la asignación de plantillas & 5\\ \hline
		H12 & T12.1 & Creación de vistas & 3\\ \hline
		H12 & T12.2 & Funciones de edición & 5\\ \hline
		H12 & T12.3 & Funciones de actualización de base de datos & 5\\ \hline
		H13 & T13.1 & Vistas para borrado & 3\\ \hline
		H13 & T13.2 & Funciones de borrado de base de datos & 3\\ \hline
	\end{tabular}
	\caption{\textit{Sprint} \#4}\label{tab:sb04}
\end{table}

\subsection{Quinta reunión 23/06/2017}
Se muestran los resultados de la implementación de las tareas del cuarto \textit{sprint}. El resultado es satisfactorio y se continúa con la elaboración de la documentación para el ac{TFM}.
\clearpage
\section{Desarrollo del proyecto}
En esta sección se expondrá el proceso de desarrollo del \ac{TFM}. Según lo expuesto en la Sección \ref{sec:metscrum}, el desarrollo está dividido en cuatro \textit{sprints} con sus diferentes tareas y cada una de ellas consta de diseño, desarrollo y pruebas. En este documento se explicarán en detalle las Historias y Tareas con mayor relevancia.

\subsection{Primer \textit{sprint}}
Como se puede observar en la Tabla \ref{tab:sb01} de la sección anterior, el primer \textit{sprint} tiene sólo una historia de usuario: ``Instalación de Entorno'', que comprende ocho tareas básicas para desplegar y comprender el funcionamiento de un entorno Drupal.

\subsubsection{Requisitos de Drupal}
Para poder ejecutar una aplicación Drupal se tienen que cumplir los siguientes requisitos:
\begin{itemize}  
	\item Espacio en disco mínimo de 60MB.
	\item Servidor web con soporte PHP como Apache, Nginx ó Microsoft IIS.
	\item Base de datos MySQL, MariaDB, Percona Server, PostgreSQL o SQLite.
	\item PHP 5.2.5 mínimo
\end{itemize}
Se decide utilizar una infraestructura \acf{WAMP} con lo que se cumplen todos los requisitos mínimos de Drupal. El esquema de WAMP se puede ver en la Figura \ref{fig:wamparch}.
Realizar una instalación para \ac{WAMP} es sencillo, simplemente hay que descargar un instalador de la página web de \ac{WAMP}\footnote{http://www.wampserver.es/} y seguir los pasos del wizard de instalación como se puede observar en la Figura \ref{fig:wampwizard}. Una vez completada la instalación, se arrancan los servicios de \ac{WAMP} navegando a la carpeta en la que se han instalado los componentes y ejecutando wampmanager.exe como se ve en la Figura \ref{fig:wampexe}.
\begin{figure}
	\centering{\includegraphics[width=\textwidth]{./imagenes/arquitecturaWAMP.png}}
	\caption{Arquitectura WAMP}
	\label{fig:wamparch}
\end{figure}
\begin{figure}
	\centering{\includegraphics[width=13cm]{./imagenes/instalacion_wamp.png}}
	\caption{Instalación de WAMP}
	\label{fig:wampwizard}
\end{figure}
\begin{figure}
	\centering{\includegraphics[width=13cm]{./imagenes/wamp_ejecutable.png}}
	\caption{Archivos de WAMP}
	\label{fig:wampexe}
\end{figure}
\clearpage
\subsubsection{Instalación de Drupal}
Hay varias formas para instalar Drupal y sus extensiones. Inicialmente se intentó usar la herramienta Composer con la cual poder crear un archivo composer.json con todos los parámetros de la instalación de Drupal, incluyendo módulos extra, y posteriormente ejecutar la instalación con un único comando de consola. Sin embargo, tras múltiples problemas relacionados con la plataforma Windows elegida, y, dado que el proceso de instalación de Drupal en sí no está incluido dentro del alcance de los propósito del \ac{TFM}, se decidió utilizar un proceso de instalación manual.\\

Para instalar Drupal manualmente, el proceso es el siguiente:
\begin{enumerate}  
	\item Descargar y extraer Drupal: El \textit{framework} no requiere instalación propiamente dicha, tan sólo hace falta descargar el archivo comprimido de la web de Drupal\footnote{https://www.drupal.org/project/drupal} y extraer los ficheros comprimidos dentro de la carpeta de aplicaciones web en la instalación de \ac{WAMP}.
	\item Crear base de datos: En el servidor de MySQL incluido en \ac{WAMP}, se crea la base de datos para la aplicación de Drupal.
	\item Ejecución de scripts de Drupal: Finalmente se navega a la aplicación creada en el punto 1 (ejemplo: http://localhost/drupal) y se siguen los pasos para completar la instalación. Esto ejecutará los scripts necesarios para completar la instalación de Drupal como se puede ver en la Figura \ref{fig:drupalins}.
\end{enumerate}

\begin{figure}
	\centering{\includegraphics[width=\textwidth]{./imagenes/Wizard_drupal.png}}
	\caption{Instalación de Drupal}
	\label{fig:drupalins}
\end{figure}
\subsubsection{Expandiendo Drupal}
Como \ac{CMS}, Drupal contiene mecanismos para que un administrador pueda agregar contenido y funcionalidad extra. Esto se realiza desde los menús de administración en la aplicación web. Para acceder a esta sección, se navega a la aplicación web del servidor local (creado en la sección anterior) y se introducen los credenciales de un usuario con privilegios, creado en el paso 3 de la instalación manual de Drupal. En la Figura \ref{fig:drupaladmin} se puede ver el menú de administración.\\
\begin{figure}
	\centering{\includegraphics[width=\textwidth]{./imagenes/Drupal_administration.png}}
	\caption{Administración de Drupal}
	\label{fig:drupaladmin}
\end{figure}

Las siguientes acciones sobre la instalación de Drupal se han llevado a cabo para el primer \textit{sprint}:
\begin{itemize}  
	\item Instalación de módulo: Para instalar un módulo de Drupal manualmente, hay que realizar una búsqueda del mismo en su web\footnote{https://www.drupal.org/project/project\_module} y descargar su fichero comprimido. Una vez descargado, se añade el módulo a Drupal mediante la opción ``Install new module'' del menú ``Modules'' como se puede observar en la Figura \ref{fig:drupalnewmodule}. Una vez añadido, el módulo y sus dependencias, se activa desde la lista de módulos, como se muestra en la Figura \ref{fig:drupalmodulelist}. Para ganar tiempo en el futuro del desarrollo, se instala directamente el módulo de Ubercart y sus dependencias.
	\item Instalación de tema: Se instala el tema Acquia Prosper de manera manual. Para ello se realiza una búsqueda en la web de descarga de temas\footnote{https://www.drupal.org/project/project\_theme} y se obtiene el fichero comprimido. Luego desde la sección ``Appearance'', se elige la opción ``Install new theme'' y se elige el archivo descargado como se puede ver en la Figura \ref{fig:drupalappearance}. Por último se instalan us dependencias y se activa desde el listado de temas de la sección ``Appearance''.
	\item Creación de contenido: Se crean contenidos, tipos de contenido, vistas y bloques de prueba para familiarizarse con la diferente funcionalidad de Drupal y productos para el posterior desarrollo del proyecto.
\end{itemize}
\begin{figure}
	\centering{\includegraphics[width=\textwidth]{./imagenes/nuevo_modulo_form.png}}
	\caption{Formulario de añadir módulo a Drupal}
	\label{fig:drupalnewmodule}
\end{figure}
\begin{figure}
	\centering{\includegraphics[width=\textwidth]{./imagenes/modules.png}}
	\caption{Lista de módulos instalados en Drupal}
	\label{fig:drupalmodulelist}
\end{figure}
\begin{figure}
	\centering{\includegraphics[width=\textwidth]{./imagenes/appearance.png}}
	\caption{Agregar nuevo tema a Drupal}
	\label{fig:drupalappearance}
\end{figure}

\subsubsection{Creación de un módulo de Drupal}
Para crear un nuevo módulo de Drupal 7, se navega a la carpeta ``sites/all/modules/'' de la instalación de Drupal, y se crea un nuevo directorio con el nombre de la nueva extensión que en este caso será ``pdf\_warp''. En este nuevo directorio se crea un fichero ``pdf\_warp.info'' con el siguiente contenido:
\begin{verbatim}
    name = PDF Warp
    description = A module that provides Drupal 7 with PDF functionality for Ubercart
    core = 7.x
    package = PDF Warp
\end{verbatim}
Esto indicará a Drupal las propiedades básicas del nuevo módulo para que lo reconozca como tal y se pueda activar desde el menú ``Modules'' de la administración.\\

Por último se crea en el directorio un fichero pdf\_warp.module que tendrá el código PHP con la funcionalidad de la extensión.

\subsection{Segundo \textit{sprint}}
Este \textit{sprint} consta de tres historias de usuario que se dividen en cinco tareas, como está reflejado en el Tabla \ref{tab:sb02} de la sección anterior. A partir de este punto empieza el desarrollo de la funcionalidad del \ac{TFM}.

\subsubsection{Diseño}
La arquitectura del módulo constará de un directorio base que contiene el archivo .info de descripción del módulo, el archivo .install con las instrucciones PHP a ejecutar durante la instalación, el archivo .module que contiene el código del módulo como la implementación de \textit{hooks} de Drupal y los archivos .tpl con las plantillas de PHP. Dentro del mismo directorio y como se puede observar en la Figura \ref{fig:folders} se incluirán una carpeta ``css'' para los estilos del módulo y una carpeta ``js'' para todo el contenido \textit{front-end} dinámico.\\
\begin{figure}
	\centering{\includegraphics[width=13cm]{./imagenes/carpetas.png}}
	\caption{Carpetas de módulo pdf\_warp}
	\label{fig:folders}
\end{figure}
La aplicación inicialmente seguirá el diseño de la Figura \ref{fig:arc} con Drupal como fuente de datos, y comunicaciones JSON con el \textit{front-end} para la generación de PDF.
\begin{figure}
	\centering{\includegraphics[width=13cm]{./imagenes/arquitecturaAplicacion.png}}
	\caption{Arquitectura de la aplicación}
	\label{fig:arc}
\end{figure}

\subsubsection{Desarrollo}
\begin{itemize}  
	\item \textbf{H01 ``Botón de generación de PDF de producto''}\\
	Se decide abordar de principio la historia de usuario H01 ``Botón de generación de PDF de producto'' ya que presenta menor complejidad y es más necesaria para la interacción humano/máquina. Para mostrar un botón en los productos de Ubercart, es necesario implementar el \textit{hook} \textit{form\_alter} en el archivo .module. Esta es la función a la que Drupal llama cada vez que pinta un formulario, de modo que se usará para comprobar si se está renderizando un formulario de producto de Ubercart y, de este modo, añadir el botón ``Generar PDF'' a cada producto. El código de este \textit{hook} es el siguiente:
	\begin{verbatim}
	    function pdf_warp_form_alter(&$form, $form_state, $form_id){
	      if (strpos($form_id, 'uc_product_add_to_cart_form') !== false) {
	        $form['to_pdf_button'] = array(
	          '#type' => 'submit',
	          '#value' => t('Generar PDF'),
	          '#submit' => array('pdf_warp_goto_generation')
	        );
	      }
	    }
	\end{verbatim}
	En dónde \textit{\&\$form} contiene la información del formulario que se está renderizando, \textit{\$form\_state} contiene la información del estado de formulario y \textit{\$form\_id} contiene el id de formulario.\\
	\item \textbf{HT02 ``Creación de vistas programáticamente''}\\
	Se necesita crear las vistas de producto y catálogo en JSON para que el código Javascript del cliente pueda trabajar con estos datos. Para ello se hace uso de los \textit{hooks} \textit{views\_api} y \textit{views\_default\_views}. Debido a que crear una vista programáticamente es complicado, lo más sencillo es crear la vista de forma manual y luego exportar el código generado a \textit{views\_default\_views} como se observa en la Figura \ref{fig:export}.
	\begin{verbatim}
	function pdf_warp_views_api() {
	// Definir path del módulo
	}
	
	functionpdf_warp_views_default_views() {
	  // Pegar código de la exportación
	  $views[$view->name] = $view;
	  return $views;
	}
	\end{verbatim}
	\begin{figure}
		\centering{\includegraphics[width=\textwidth]{./imagenes/exportar_vista.png}}
		\caption{Exportación de vista a código PHP}
		\label{fig:export}
	\end{figure}
	\item \textbf{H02 ``Generación de PDF de producto''}\\
	Tras concluir la implementación de la historia H01 y HT02, se empieza con la H02 ``Generación de PDF de producto''. En esta historia de usuario se necesita añadir las librerías de generación de PDF, implementar la funcionalidad del lado del cliente y agregar el lanzado de la generación al botón de la historia H01.\\
	
	Para no sobrecargar las páginas de Drupal con librerías que no necesitan, se cargará el código Javascript localmente en las páginas en las que sea necesario. Con este fin, se crea una nueva página que realizará la generación de PDF.\\
	El proceso de creación de una nueva página requiere implementar los \textit{hooks} \textit{menu} y \textit{theme} en el archivo .module. Estas funciones son llamadas por Drupal cuando se va a generar el árbol de navegación y los temas.\\
	En el \textit{hook} \textit{menu}, se añade un nuevo elemento al \textit{array} \$items con su título, descripción, \textit{callback}, argumentos de página y privilegios necesarios para acceder. La implementación es la siguiente:
	\begin{verbatim}
    function pdf_warp_menu() {
      $items['pdf_warp/generate/product/%'] = array(
       'title'            => 'PDF Warp generación',
       'description'      => 'Generación de PDF',
       'page callback'    => 'pdf_warp_generate_product_page',
       'page arguments'   => array(3),
       'access arguments' => array('access content'),
      );
    }
	\end{verbatim}
	En este caso se establece que se está creando una página de título ``PDF Warp generación'', con llamada función de .module ``pdf\_warp\_generate\_product\_page'' en el paso previo a su renderizado, con un argumento que viene dado por el índice 3 de la url y que se requiere el privilegio de acceso a contenido para su navegación.\\
	
	Para el \textit{hook} \textit{theme} se devuelve un array de elementos que contienen un atributo \textit{template} con el nombre del fichero dentro del directorio del módulo que contiene el código de dicha plantilla:
	\begin{verbatim}
	    function pdf_warp_theme(){
	      return array(
	        'pdf_warp_generation' => array (
	          'template' => 'pdf-warp-generation'
	        )
	      );
	    }
	\end{verbatim}
	
	Teniendo los hooks, se programa la función ``pdf\_warp\_generate\_product\_page''. Esta función tiene un argumento que será el contenido de ``page arguments''. Aquí se realiza la inyección de las librerías de Javascript con el uso de drupal\_add\_js:
	\begin{verbatim}
    function pdf_warp_generate_product_page($id_item) {
      $path = drupal_get_path('module', 'pdf_warp');
      
      drupal_add_js($path.'/js/pdf_warp_generation.js');
      drupal_add_js($path.'/js/vendor/jspdf.min.js');
      drupal_add_js($path.'/js/vendor/html2pdf.js');

      return theme('pdf_warp_generation');
    }
    \end{verbatim}
    Una vez integradas las librerías de Javascript en Drupal se procede a implementar las funciones de generación PDF en el lado del cliente. Para ello se crea dentro de la carpeta ``js'' de pdf\_warp un fichero pdf\_warp\_generation.js que ya estamos referenciando en la función anterior.
    En este fichero se hace uso de las librerías de JsPDF para generar un documento PDF del producto con id \$id\_item. Para conseguir los datos de este producto en JSON, se hace uso de las vistas definidas previamente mediante una llamada ajax a:
    \begin{verbatim}
      base_url + '/store/catalog/' + id + '/json'
    \end{verbatim}
    siendo \textit{base\_ur}l la url de base de la aplicación Drupal e \textit{id} el id del producto. Con esta información en el Javascript se puede generar un pdf de manera programática haciendo uso de las funciones de la librería JsPDF:
    \begin{verbatim}
    var doc = new jsPDF('portrait','pt','a4');
    var pdf_elements = vm.initTemplate.pdf_elements
    doc.setFontSize(16 * 72 / 96);
    doc.text(pdf_elements[key].x * 72 / 96 + 40 * 72 / 96,
        pdf_elements[key].y * 72 / 96 + 40 * 72 / 96,
        product[index].product.Title
    );
    doc.setFontSize(10 * 72 / 96);
    doc.text(pdf_elements[key].x * 72 / 96 + 40 * 72 / 96,
        pdf_elements[key].y * 72 / 96 + 60 * 72 / 96, 
        'SKU:' + product[index].product.SKU
    );
    doc.setFontSize(22 * 72 / 96);
    doc.text(pdf_elements[key].x * 72 / 96 + 100 * 72 / 96,
        pdf_elements[key].y * 72 / 96 + 300 * 72 / 96,
        product[index].product.Price
    );
    doc.save('producto.pdf');
    \end{verbatim}
    
    Con esta funcionalidad, al hacer click en el botón se generará un PDF del producto asociado a dicho botón.
\end{itemize}

\subsubsection{Pruebas}
Las pruebas realizadas son las siguientes:
\begin{itemize}
	\item Se comprueba que el botón ``Generar PDF'' únicamente se genera para los productos.
	\item Se prueba el botón de ``Generar PDF '' de cada producto para comprobar que se generan documentos PDF distintos en función del producto al que pertenecen.
	\item Se comprueba que las vistas en JSON devuelven el contenido correcto de un producto.
	\item Se comprueba que los \textit{hooks} implementados funcionan correctamente.
\end{itemize}

\subsection{Tercer \textit{sprint}}
El tercer \textit{sprint} consta de cinco historias de usuario que se dividen en doce tareas, como está reflejado en la Tabla \ref{tab:sb03}. Al ser más largo y complejo que el resto, ya que se han realizado cambios en la funcionalidad general, se cuenta con un período de dos semanas para su realización.

\subsubsection{Diseño}
Para este \textit{sprint} se pide el uso de plantillas PDF que servirán para generar los documentos con los elementos en el sitio que decidamos. Para este fin se necesita diseñar una estructura de datos que contenga la plantilla. Contendrá los siguientes campos:
\begin{itemize}
	\item Nombre: el nombre de la plantilla.
	\item Tipo: el tipo de plantilla, si de catálogo o de producto.
	\item Tipo de renderizado: imagen o texto.
	\item Activo: para saber si la plantilla está activa o no.
	\item Contenido: El contenido en \ac{JSON} de la plantilla con sus elementos. Se trata de un objeto \ac{JSON} que a su vez contiene dos objetos llamados pdf\_elements y edit\_elements que contienen una lista de elementos para la generación de PDF y para la edición de la plantilla respectivamente, ya que las posiciones de estos elementos en el modo edición son relativas.
\end{itemize}

Para almacenar la información de plantilla se diseña una nueva tabla de base de datos que contendrá las plantillas PDF. Esta tabla contará con los siguientes campos:
\begin{itemize}
	\item id: identificador de plantilla de tipo UNSIGNED INT.
	\item name: nombre de la plantilla de tipo VARCHAR(255).
	\item type: el tipo de plantilla de tipo VARCHAR(32) con valor por defecto 'catalog' siendo el otro valor 'product'.
	\item render\_mode: el modo de renderizado de tipo VARCHAR(32). Por defecto 'imagen'.
	\item active: para saber si la plantilla está activa o no de tipo TINYINT con 1 activo y 0 no activo.
	\item content: El contenido en JSON de tipo TEXT y tamaño medio.
\end{itemize}

Por otro lado se requiere una sección de administración para que un usuario con privilegios pueda gestionar plantillas. Se decide incluir una pestaña de administración dentro de la sección ``Appearance''. El diseño de las pantallas se puede ver en las Figuras \ref{fig:diseno1},\ref{fig:diseno2} y \ref{fig:diseno3}.\\
\begin{figure}
	\centering{\includegraphics[width=\textwidth]{./imagenes/disenoAdminPpal.png}}
	\caption{Diseño de pantalla principal de administración}
	\label{fig:diseno1}
\end{figure}
\begin{figure}
	\centering{\includegraphics[width=10cm]{./imagenes/disenoAdminCreacion.png}}
	\caption{Diseño de creación de plantilla}
	\label{fig:diseno2}
\end{figure}
\begin{figure}
	\centering{\includegraphics[width=\textwidth]{./imagenes/EditarProducto.png}}
	\caption{Diseño de edición de plantilla}
	\label{fig:diseno3}
\end{figure}

\subsubsection{Desarrollo}

\begin{itemize}
	\item \textbf{H03 ``Creación de plantillas de producto''}\\
	El primer paso en la creación de las plantillas es asegurarse de que es posible persistir los datos, de manera que se procede a crear la tabla de la base de datos. Esta tabla debe desplegarse durante la instalación del módulo para asegurar que sea exportable, y debe borrarse una vez se desinstale el módulo. Para ello se crea un nuevo archivo pdf\_warp.install en la raíz del módulo. En este fichero se implementan los \textit{hooks} \textit{install, uninstall y schema}. \textit{Install} y \textit{uninstall} como su nombre indica instalaran y desinstalarán nuestro \textit{schema} según se instale o elimine el módulo. \textit{Schema} contiene la definición de la tabla de base de datos. La implementación se puede observar a continuación:
	\begin{verbatim}
	function pdf_warp_install() {
	  drupal_install_schema('pdf_warp');
	}
	
	function pdf_warp_uninstall() {
	  drupal_uninstall_schema('pdf_warp');
	}
	function pdf_warp_schema() {
	  $schema['pdf_warp_templates'] = array(
	    'description' => t('Tabla de plantillas del módulo PDF Warp.'),
	    'fields' => array(
	      'id' => array(
	        'description' => 'Identificador de plantila',
	        'type'        => 'serial',
	        'unsigned'    => TRUE,
	        'not null'    => TRUE),
	      'name' => array(
	        'description' => 'Nombre de la plantilla',
	        //...RESTO DE CAMPOS
	    ),
	    'primary key' => array('id')
	  );
	  return $schema;
	}
	\end{verbatim}
	Para que un usuario con privilegios pueda crear plantillas, necesita una serie de páginas de administración, como por ejemplo una página para ver todas las plantillas, y otra para darlas de alta. Como hemos explicado en el \textit{sprint} anterior, este proceso se realiza mediante el \textit{hook menu} con la diferencia de que las páginas nuevas deberán estar contenidas en la ruta ``admin/appearance/'' y con privilegios ``administer site configuration''. El tipo de la página principal ``MENU\_LOCAL\_TASK'', esto generará una nueva pestaña en ``Appearance''. El tipo de la página para añadir plantilla será MENU\_LOCAL\_ACTION para que genere un botón de ``Nueva plantilla''. Las nuevas páginas se definen con el siguiente código dentro del \textit{hook menu} implementado previamente:
	\begin{verbatim}
    $items['admin/appearance/pdf_warp'] = array(
      'title'            => 'PDF Warp',
      'description'      => 'Configuración de plantillas',
      'page callback'    => 'pdf_warp_admin_page',
      'access arguments' => array('administer site configuration'),
      'type'             => MENU_LOCAL_TASK,
    );
    $items['admin/appearance/pdf_warp/add'] = array(
      'title' => t('Nueva plantilla'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('pdf_warp_form_add_template'),
      'access arguments' => array('administer site configuration'),
      'type' => MENU_LOCAL_ACTION,
    );
	\end{verbatim}
	Posteriormente se implementan las funciones de \textit{callback}, \textit{pdf\_warp\_admin\_page} y \textit{pdf\_warp\_form\_add\_template}, para generar el contenido de las páginas, además para el formulario de creación de plantilla se requiere implementar uan nueva función \textit{pdf\_warp\_form\_add\_templat\_submit} que contendrá el código para crear una nueva plantilla en base de datos. El aspecto que presentan se puede ver en las Figuras \ref{fig:adminpdf2} y \ref{fig:adminpdf3}.\\

	Una vez tenemos la plantilla creada, se modifica la generación de PDF de producto para que haga uso de ella en vez de una prefijada. Para ello tan sólo modificamos la función del back que renderiza la página de generación de PDF para que envíe el JSON de nuestra plantilla a la página de generación, en los \textit{settings} de Drupal:
	\clearpage
	\begin{verbatim}
	function pdf_warp_generate_product_page($id_item) {
	  ...
	  $sql = "SELECT * FROM {pdf_warp_templates} WHERE active=1
	  AND type='product'";
	  $settings['pdf_warp']['template_content'] =
	  db_query($sql)->fetchAll();
	  drupal_add_js($settings, 'setting');
	  
	  return theme('pdf_warp_generation');
	}
	\end{verbatim}
	\begin{figure}[h]
		\centering{\includegraphics[width=\textwidth]{./imagenes/administracion2.png}}
		\caption{Página de administración principal}
		\label{fig:adminpdf2}
	\end{figure}
	\clearpage
	\begin{figure}
		\centering{\includegraphics[width=\textwidth]{./imagenes/administracion3.png}}
		\caption{Página de creación de plantilla}
		\label{fig:adminpdf3}
	\end{figure}
	\item \textbf{H04 ``Asignación de plantillas de producto''}\\
	Para la asignación o activación de plantillas el proceso es sencillo. Se crea una nueva página de formulario implementando el \textit{hook menu} y su función de \textit{callback} que se llamará pdf\_warp\_template\_enable\_confirm. El código que se añade al \textit{hook} es el siguiente:
	\begin{verbatim}
	$items['admin/appearance/pdf_warp/enable/%'] = array(
	  'title' => t('Activar plantilla'),
	  'page callback' => 'drupal_get_form',
	  'page arguments' => array('pdf_warp_template_enable_confirm', 4),
	  'access arguments' => array('administer site configuration'),
	  'access callback' => TRUE,
	  'type' => MENU_CALLBACK, 
	);
	\end{verbatim}
	 A está página se navegará desde un botón contenido en la tabla de plantillas de la pantalla principal de administración. Su funcionamiento será el de activar la plantilla seleccionada y desactivar el resto de plantillas. Para ello se hacen dos operaciones de \textit{update} en base de datos, una que ponga a 0 el campo \textit{active} de todas las plantillas del tipo seleccionado (catálogo o producto) y otra para marcar con 1 el campo \textit{active} de la plantilla seleccionada.
	 
	\item \textbf{H05 ``Mover elementos en plantillas de producto''}\\
	Esta historia de usuario requiere realizar desarrollos tanto en el \textit{back-end} como en el \textit{front-end} y realizar una comunicación entre ellos. Debido a que la edición de plantillas requiere una interfaz de usuario dinámica e interactiva, se decide integrar AngularJS en el \textit{front-end} para poder utilizar todos los desarrollos de la comunidad que necesitemos.
	Para ello una de las dependencias del módulo será la extensión AngularJS Bridge que añade cualquier versión del \textit{framework} a Drupal.\\
	Una vez realizada la instalación y activación de la dependencia, se procede a crear las páginas de edición. Se crean dos nuevas entradas mediante el \textit{hook menu} una que contiene la funcionalidad de edición y otra un \textit{endpoint} al que llamar cuando se quieran guardar los cambios. Estas páginas sólo podrán ser accedidas por un usuario con privilegios. Se definen con el siguiente código:
	\begin{verbatim}
	$items['admin/appearance/pdf_warp/edit/%'] = array(
	  'title' => t('Editar plantilla'),
	  'page callback' => 'pdf_warp_edit_template_page',
	  'page arguments' => array(4),
	  'access arguments' => array('administer site configuration'),
	  'type' => MENU_CALLBACK,
	);
	
	$items['admin/appearance/pdf_warp/edit/%/save'] = array(
	  'title' => t('Guardar plantilla'),
	  'page callback' => 'pdf_warp_save_edit',
	  'page arguments' => array(4),
	  'access arguments' => array('administer site configuration'),
	  'type' => MENU_CALLBACK, 
	);
	\end{verbatim}
	
	En la función de \textit{callback} de la página de edición, se tienen que cargar todas las librerías \textit{front-end} necesarias y enviar el contenido de la plantilla desde base de datos. El código sería el siguiente:
	\begin{verbatim}
	function pdf_warp_edit_template_page($id_template) {
	  drupal_add_library('angularjs', 'angularjs');
	
	  $path = drupal_get_path('module', 'pdf_warp');
	  drupal_add_css($path.'/css/pdf_warp_template.css');
	  drupal_add_js($path.'/js/pdf_warp.js');
	  drupal_add_js($path.'/js/vendor/jspdf.min.js');
	  drupal_add_js($path.'/js/vendor/html2pdf.js');
	  drupal_add_js($path.'/js/vendor/bower_.../../classie.js');
	  drupal_add_js(
	    $path.'/js/vendor/bower_.../../EventEmitter.js'
	  );
	  drupal_add_js(
	    $path.'/js/vendor/bower_components/eventie/eventie.js'
	  );
	  drupal_add_js(
	    $path.'/js/vendor/bower_.../../get-style-property.js'
	  );
	  drupal_add_js(
	    $path.'/js/vendor/bower_.../../get-size.js'
	  );
	  drupal_add_js(
	    $path.'/js/vendor/bower_.../../draggabilly.js'
	  );
	  drupal_add_js(
	    $path.'/js/vendor/bower_.../../angular-draggabilly.js'
	  );
	
	  $sql = "SELECT * FROM {pdf_warp_templates} WHERE id=".$id_template;
	  $settings['pdf_warp']['template_content'] = db_query($sql)->fetchAll();
	  $sql = "SELECT nid FROM {uc_products}";
	  $settings['pdf_warp']['products'] = db_query($sql)->fetchAll();
	  drupal_add_js($settings, 'setting');
	
	  return theme('pdf_warp_template');
	}
	\end{verbatim}
	Como se puede observar, se incuyen librerías extra desde la carpeta \textit{vendor} para poder usar la extensión de AngularJs Draggabilly que nos permite mover elementos mediante \textit{drag and drop} al punto que queramos dentro de un elemento contenedor.\\
	
	La página de edición AngularJS se divide en dos ficheros, uno que contiene la lógica de la página llamado pdf\_warp.js  y otro con la el código \ac{HTML} representando la vista de nombre pdf-warp-template.tpl.php.
	La página resultante se puede ver en la Figura \ref{fig:adminpdf4}.
	\begin{figure}
		\centering{\includegraphics[width=\textwidth]{./imagenes/administracion4.png}}
		\caption{Página de edición de plantilla}
		\label{fig:adminpdf4}
	\end{figure}
	
	\item \textbf{H06 ``Borrado de plantillas de producto''}\\
	El borrado de plantillas de producto también se realiza de manera sencilla. Se crea una nueva página de formulario implementando el \textit{hook menu} y su función de \textit{callback} que se llamará pdf\_warp\_template\_delete\_confirm. El código que se añade al \textit{hook} es el siguiente:
	\begin{verbatim}
	$items['admin/appearance/pdf_warp/delete/%'] = array(
	  'title' => t('Borrar plantilla'),
	  'page callback' => 'drupal_get_form',
	  'page arguments' => array('pdf_warp_template_delete_confirm', 4),
	  'access arguments' => array('administer site configuration'),
	  'access callback' => TRUE,
	  'type' => MENU_CALLBACK, 
	);
	\end{verbatim}
	A está página se navegará desde un botón contenido en la tabla de plantillas de la pantalla principal de administración. Al pulsar este botón se navegará a una página de confirmación para borrar la plantilla seleccionad. Para ello se realiza una operación de borrado en base de datos por id de plantilla.
	
	\item \textbf{H07 ``Acceso a sección de gestión de plantilla''}\\
	Esta historia de usuario se lleva a cabo de manera conjunta con la historia H03 ``Creación de plantillas de producto'' ya que al agregar las nueva página de administración de tipo \textit{MENU\_LOCAL\_TASK} dentro de la navegación de un menú existente, obtenemos un botón de acceso, o, en este caso, una pestaña.
\end{itemize}
\subsubsection{Pruebas}
Las pruebas realizadas en este \textit{sprint} son las siguientes:
\begin{itemize}
	\item Creación de plantillas de producto.
	\item Borrado de plantillas de producto.
	\item Edición de plantillas de producto.
	\item Activado de plantillas de producto.
	\item Generación de PDF a partir de plantillas de producto.
\end{itemize}

\subsection{Cuarto \textit{sprint}}
El último \textit{sprint} consta de seis historias de usuario que se dividen en doce tareas, como está reflejado en la Tabla \ref{tab:sb04}. Este \textit{sprint} aún siendo similar en tamaño al anterior, tiene menor complejidad ya que podemos reutilizar código y experiencia previa para realizar un desarrollo más ágil, por ello el tiempo estimado es de una semana.

\subsubsection{Diseño}
Lo único nuevo en cuestión de diseño en este \textit{sprint} es la pantalla de edición de plantillas de catálogos que podemos ver en la Figura \ref{fig:diseno4}.
\begin{figure}
	\centering{\includegraphics[width=\textwidth]{./imagenes/disenoCatalogo.png}}
	\caption{Diseño de edición de plantilla de catálogo}
	\label{fig:diseno4}
\end{figure}

\subsubsection{Desarrollo}
\begin{itemize}
	\item \textbf{H08 ``Botón de generación de PDF de catálogo''}\\
	Para la creación de un botón que genere documentos PDF a partir de catálogos, se requiere el uso del \textit{hook page\_alter} ya que al contrario que con productos, no se está asociando la generación a un único formulario de producto, sino a un catálogo que se muestra en una página completa.
	El código de implementación del \textit{hook} es el siguiente: 
	\begin{verbatim}
	function pdf_warp_page_alter(&$page){
	  if (strpos($page['content']['system_main']
	  ['products']['#markup'], 'view-uc-catalog') != false){
	    $url = explode("/", current_path());
	    $page['content']['system_main']['products']['#markup'] =
	    $page['content']['system_main']['products']['#markup'].
	    '<a href="'.$GLOBALS['base_url'].
	    '/pdf_warp/generate/catalog/'.
	    $url[1].'";
	  }
	}
	\end{verbatim}
	Con esta implementación aparecerá un botón en cada catálogo que navegue a la página /pdf\_warp/generate/catalog/{id} en la que se desarrollará la generación del PDF de catálogo.
	
	\item \textbf{``H09 Generación de PDF de catálogo''}\\
	Al igual que en el segundo \textit{sprint} se crea la página de generación de PDF a partir de plantillas de catálogo. En el \textit{hook} \textit{menu} se añade un elemento nuevo, el código es el siguiente:
	\begin{verbatim}
	$items['pdf_warp/generate/catalog/%'] = array(
	  'title'            => 'PDF Warp generación',
	  'description'      => 'Generación de PDF',
	  'page callback'    => 'pdf_warp_generate_catalog_page',
	  'page arguments'   => array(3),
	  'access arguments' => array('access content'),
	);
	\end{verbatim}
	También es necesario crear nuevos temas, para utilizar las páginas \textit{front-end} de catálogos:
	\clearpage
	\begin{verbatim}
	function pdf_warp_theme(){
	  return array(
	  ...
	  'pdf_warp_catalog_template' => array (
	    'template' => 'pdf-warp-catalog-template'
	  )
	  ,
	  'pdf_warp_catalog_generation' => array (
	    'template' => 'pdf-warp-catalog-generation'
	  )
	);
	}
	\end{verbatim}
	La función de \textit{callback} de la página de generación, será prácticamente igual que la de producto, con la diferencia de que se cargan otros recursos,se envía una plantilla de tipo \textit{catalog} y se devuelve otro tema distinto.
	\begin{verbatim}
	function pdf_warp_generate_catalog_page($id_item) {
	  ...
	  $path = drupal_get_path('module', 'pdf_warp');
	  drupal_add_js($path.'/js/pdf_warp_catalog_generation.js');
	  drupal_add_js($path.'/js/vendor/jspdf.min.js');
	  drupal_add_js($path.'/js/vendor/html2pdf.js');
	  ...
	  $sql = "SELECT * FROM {pdf_warp_templates} WHERE active=1 AND type='catalog'";
	  $settings['pdf_warp']['template_content'] = db_query($sql)->fetchAll();
	  drupal_add_js($settings, 'setting');
	
	  return theme('pdf_warp_catalog_generation');
	}
	\end{verbatim}
	
	Habiendo creado la página de generación con las librerías necesarias inyectadas, se puede implementar el código de generación del documento PDF de catálogo en el archivo pdf\_warp\_catalog\_generation.js, el cuál será similar al de productos con la diferencia de que se generan páginas diferentes dependiendo del número de elementos por página deseado:
	\begin{verbatim}
	...
	var doc = new jsPDF('portrait','pt','a4');
	var pdf_elements = vm.initTemplate.pdf_elements
	
	angular.forEach(splitProducts, function(product, productIndex) {
	  if (productIndex > 0){
	    doc.addPage();
	  }
	  angular.forEach(Object.keys(pdf_elements), function(key, index) {
	    if (product[index]) {
	      doc.setFontSize(16 * 72 / 96);
	      doc.text(pdf_elements[key].x * 72 / 96 + 40 * 72 / 96,
	        pdf_elements[key].y * 72 / 96 + 40 * 72 / 96,
	        product[index].product.Title);
	      doc.setFontSize(10 * 72 / 96);
	      doc.text(pdf_elements[key].x * 72 / 96 + 40 * 72 / 96,
	        pdf_elements[key].y * 72 / 96 + 60 * 72 / 96,
	        'SKU:' + product[index].product.SKU);
	      doc.setFontSize(22 * 72 / 96);
	      doc.text(pdf_elements[key].x * 72 / 96 + 100 * 72 / 96,
	        pdf_elements[key].y * 72 / 96 + 300 * 72 / 96,
	        product[index].product.Price);
	    }
	  });             
	});
	...
	\end{verbatim}
	
	Con esta implementación al hacer click en el botón creado en la historia de usuario anterior, se generará un documento PDF de catálogo a partir de su plantilla.
	
	\item \textbf{``H10 Creación de plantillas de catálogo''}\\
	Para la creación de plantillas de catálogo se añade un elemento en el formulario de creación de plantillas y una condición en la función de creación:
	\begin{verbatim}
	function pdf_warp_form_add_template_submit(&$form, $form_state) {
 	  ...
	  'type' => $form_state['values']
	    ['template_type'] == 0 ? 'product' : 'catalog'
	  ...
	}
	\end{verbatim}
	
	\item \textbf{H11 ``Asignación de plantillas de catálogo''}\\
	Para la activación de plantillas de catálogo, se añade código a la función de activación de plantillas para que se diferencie entre una plantilla de cátalogo y otra de producto. En concreto se realiza una consulta en la que se obtiene la información de plantilla para poder saber si estamos activando una plantilla de producto o catálogo. El código añadido es el siguiente:
	\begin{verbatim}
	function pdf_warp_template_enable_confirm_submit($form, &$form_state) {
	  ...
	 $sql = "SELECT * FROM {pdf_warp_templates} WHERE id=".$id_template;
	  $templateResult = db_query($sql);
	  $templateType = 'product';
	
	  foreach ($templateResult as $v) {
	    $templateType = $v->type;
	  }
	  ...
	}
	\end{verbatim}
	
	\item \textbf{H12 ``Mover elementos en plantillas de catálogo''}\\
	Esta historia de usuario, al igual que su homónima de productos, requiere realizar desarrollos tanto en el \textit{back-end} como en el \textit{front-end}. Se deben crear nuevas páginas de edición de plantillas de catálogo que también integren las librerías de AngularJS y Draggabilly, ya que la funcionalidad general será parecida. Las páginas que se añaden al \textit{hook menu} son las siguientes:
	\begin{verbatim}
	$items['admin/appearance/pdf_warp/edit/catalog/%'] = array(
	  'title' => t('Editar plantilla de catálogo'),
	  'page callback' => 'pdf_warp_edit_catalog_template_page',
	  'page arguments' => array(5),
	  'access arguments' => array('administer site configuration'),
	  'type' => MENU_CALLBACK,
	);
	
	$items['admin/appearance/pdf_warp/edit/catalog/%/save'] = array(
	  'title' => t('Guardar plantilla'),
	  'page callback' => 'pdf_warp_catalog_save_edit',
	  'page arguments' => array(5),
	  'access arguments' => array('administer site configuration'),
	  'type' => MENU_CALLBACK, 
	);
	\end{verbatim}
	
	Al igual que con los catálogos, en la función de \textit{callback} de la página de edición, se tienen que cargar todas las librerías \textit{front-end} necesarias y enviar el contenido de la plantilla desde base de datos. El código sería el siguiente:
	\begin{verbatim}
	function pdf_warp_edit_template_page($id_template) {
	  // CARGA DE LIBRERÍAS
	
	  $sql = "SELECT * FROM {pdf_warp_templates} WHERE id=".$id_template;
	  $settings['pdf_warp']['template_content'] = db_query($sql)->fetchAll();
	  drupal_add_js($settings, 'setting');
	
	  return theme('pdf_warp_catalog_template');
	}
	\end{verbatim}
	
	La página de edición de plantillas de catálogo se divide en dos ficheros, uno que contiene la lógica de la página llamado pdf\_warp\_catalog.js  y otro con la el código \ac{HTML} representando la vista de nombre pdf-warp-catalog-template.tpl.php.
	La página resultante se puede ver en la Figura \ref{fig:adminpdf5}.
	
	\item \textbf{H13 ``Borrado de plantillas de catálogo''}\\
	El borrado de plantillas de catálogo no requiere código extra, ya que el borrado inicial se realiza por ID de plantilla y no entra en conflicto con la implementación previa.
\end{itemize}

\subsubsection{Pruebas}
Las pruebas realizadas en este \textit{sprint} son las siguientes:
\begin{itemize}
	\item Creación de plantillas de catálogo.
	\item Borrado de plantillas de catálogo.
	\item Edición de plantillas de catálogo.
	\item Activado de plantillas de catálogo.
	\item Generación de PDF a partir de plantillas de catálogo.
\end{itemize}

\begin{figure}[h]
	\centering{\includegraphics[width=\textwidth]{./imagenes/administracion5.png}}
	\caption{Diseño de edición de plantilla de catálogo}
	\label{fig:adminpdf5}
\end{figure}